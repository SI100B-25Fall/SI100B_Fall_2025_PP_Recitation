---
title: SI100B_Fall_2025_Recitation_2
separator: <!--s-->
verticalSeparator: <!--v-->
theme: simple
highlightTheme: github
css: assets/custom.css
autoTitlePage: true
makeTitle:
    lecture: SI100B Fall 2025 Recitation 2
    title: L4 课堂复习 & HW1 讲解
    detail: SI100B 2025 Staff | 2025-10-10
makeThanks: true
---

# 作业讲解
<!--s-->
# problem 1

<!--v-->
判断是否是数字，判断是否是合法的  
知识点：条件语句、循环语句、输入输出、内置函数isdigit，join  
## 标准答案
```
n = input()
if not n.isdigit():
    print("Invalid")
else:
    n = int(n)    
    if 0 < n < 10:
        for i in range(1, n + 1):
            row = '\t'.join(f'{j}x{i}={i*j:2}' for j in range(1, i + 1))
            print(row)
    else:
        print("Invalid")
```
<!--v-->
## 优化1:链式比较（拓展）
把if 0 < n and n < 10: 改成 if 0 < n < 10:  
Python允许链式比较，这是它的一大特色！ 与许多其他编程语言不同：
## 链式写法
```
0 < n < 10           # ✓ 合法且推荐
1 < x <= 5 < y < 10  # ✓ 完全合法
```
## 等价的传统写法
```
0 < n and n < 10                    # ✓ 也可以
1 < x and x <= 5 and 5 < y and y < 10  # ✓ 冗长
```
<!--v-->
优势：
1. 可读性更好，更接近数学表达式
2. 性能更高，中间变量只求值一次
3. 更加Pythonic 参考[python的设计哲学](https://realpython.com/ref/glossary/pythonic/)

<!--v-->
## 代码点评
比较让人疑惑的写法: 退出程序为什么要使用exit？为什么不能使用分支控制程序行为？
```
import sys
sys.exit()
```
```
num=input()
try:
    num = float(num)
except ValueError:
    print('Invalid')
    exit()
```
<!--v-->
## Q1暴露出的一些问题 

1. 不看提示中的f"{j}x{i}={i*j:2}"，也没看special hint，不关注题目给的样例，不看题目是大忌，之后题目难起来容易被卡死

2. 存在一些命名不规范的问题，有些变量命名过多且没有注释辅助理解

3. 题目是为了帮助你们理解编程的基本概念，暴力查表不利于练习编程能力

4. 再次强调，input里面不要自己放东西，OJ会将之视为输出并让所有测试点全错

5. 再次强调，**不要**依赖AI！**不要**使用AI完成你们的题目！

<!--s-->
# problem 4
<!--v-->
## 标准答案
```
a = float(input())
guess = a / 2
for _ in range(20):
    guess = (guess + a / guess) / 2
print("{0:.20f}".format(guess))
```

<!--s-->
# problem 5
<!--v-->
## 标准答案
```
s = input()
n = len(s)
cnt = 0

for c in range(n):
    l = r = c
    while l >= 0 and r < n and s[l] == s[r]:
        cnt += 1
        l -= 1
        r += 1

for c in range(n - 1):
    l, r = c, c + 1
    while l >= 0 and r < n and s[l] == s[r]:
        cnt += 1
        l -= 1
        r += 1

print(cnt)
```
<!--v-->
## 知识点1：尽量使用内置的方法（拓展）
这一算法运行时间会比较长，但是可以通过测试点
```
s = input()
n = len(s)
count = 0
for i in range(n):
    for j in range(i, n):
        if s[i:j+1] == s[i:j+1][::-1]:
            count += 1
print(count)
```
<!--v-->
而下面这一算法将会超时
```
s = input()
n = len(s)
count = 0
for i in range(n):
    for j in range(i, n):
        for k in range((j - i + 1) // 2):
            if s[i + k] != s[j - k]:
                break
        else:
            count += 1
print(count)
```
虽然从**理论时间复杂度**的角度看，这两种暴力算法**都是 O(n³) 级别**的，但**在实际运行中，算法1会比算法2快得多**。

原因在于 **Python 解释器的工作方式** 和 **底层代码的实现语言**。

<!--v-->
### 核心原因：C语言实现 vs. Python循环

#### 算法1: `s[i:j+1] == s[i:j+1][::-1]`
这个操作看起来很简单，但在幕后，Python 正在做几件效率极高的事情：
1.  **`s[i:j+1]` (切片)**: 这是一个单一的操作。Python 的底层实现（用C语言编写）会快速地在内存中定位并复制出这一段子字符串。这是一个高度优化的 C 操作。
2.  **`[::-1]` (反转)**: 同样，对一个字符串进行反转也是一个单一的、由优化的C代码执行的操作。它会创建一个新的、反转后的字符串。
3.  **`==` (比较)**: 两个字符串的比较也是在C语言层面完成的，它会逐字节地快速比较内存中的数据。

**关键点**：整个回文检查被打包成了一行代码，Python 解释器将这些任务“委托”给了它内部编译好的、速度极快的C语言代码库去执行。这几乎没有 Python 解释器本身的开销。

<!--v-->
#### 算法2: `for k in range(...)`
这个算法通过一个显式的 `for` 循环来逐个比较字符：
1.  **Python `for` 循环**: 这个循环是在 Python 解释器层面运行的。对于循环的每一次迭代，解释器都需要做很多额外的工作：
    *   更新循环变量 `k`。
    *   计算索引 `i + k` 和 `j - k`。
    *   进行数组边界检查。
    *   获取 `s[i + k]` 的值。
    *   获取 `s[j - k]` 的值。
    *   执行 `if` 判断。
    *   如果条件不满足，执行 `break`。
<!--v-->
2.  **解释器开销 (Interpreter Overhead)**: 每一步操作都要经过 Python 解释器的处理。这种“解释”本身是有成本的，它远比直接执行编译好的C代码要慢。当字符串很长时，这个 `k` 循环会被执行成千上万次，每次迭代的微小开销累加起来就变得非常巨大。

---

<!--v-->
### 一个形象的比喻

*   **算法1** 就像你告诉一位专业的图书管理员（C语言代码）：“请帮我把这摞书（子字符串）复制一份，再把复制的那份倒序排列，然后告诉我这两摞书是否完全一样。” 管理员用他最熟练、最高效的方法一次性完成了任务。
*   **算法2** 就像你自己（Python解释器）来做这件事。你先拿起第一本书和最后一本书，比较一下；然后拿起第二本书和倒数第二本书，比较一下…… 你每比较一次，都需要思考、计算位置、再动手，这个过程中的“思考和准备”时间（解释器开销）远远超过了“比较”本身。

<!--v-->
### 结论

这个例子完美地展示了一个在 Python (以及许多其他高级语言) 中非常重要的编程原则：

**尽可能利用语言内置的、经过高度优化的函数和操作来处理批量数据，而不是自己用显式的循环去实现。**

虽然两种算法的扩展趋势（scaling）是一样的（都是立方级增长），但由于实现方式的不同，算法1的“常数因子”要远远小于算法2，导致在实际运行中表现出巨大的性能差异。


<!--v-->
## 知识点2：时间复杂度（扩展）
### 核心思想

**时间复杂度** 不是用来测量程序运行究竟要花“多少秒”，而是用来描述**一个程序的运行时间会随着处理数据量的增加，而增长得有多“快”**。

它是一种预测，帮助我们判断一个算法在处理大数据时，会不会变得慢得离谱。

---

### 用“做菜”来打比方

假设你是一位厨师，你的任务是为客人准备晚餐。在这里：
*   **算法**：就是你的“操作”。
*   **输入大小 (n)**：就是你要招待的“客人数量”。
*   **时间复杂度**：就是你的操作有多复杂，特别是当客人数量 (n) 增加时，你的工作量会如何变化。

现在我们来看几种不同“时间复杂度”的操作：

#### 1. O(1) — 常数时间 (最快的)

**操作：“尝一下汤的味道。”**

*   **分析**：不管你是为 1 位客人做汤，还是为 1000 位客人做汤，你“尝一口”这个动作花费的时间是**完全一样**的。它不随客人数量 (n) 的变化而变化。
*   **在代码中**：这就像从数组中获取第一个元素 `array[0]`。无论数组有多大，这个操作都一样快。
*   **特点**：性能极高，是理想情况。

---

#### 2. O(n) — 线性时间 (优秀的)

**操作：“为每一位客人削一个苹果。”**

*   **分析**：
    *   如果来了 1 位客人 (n=1)，你削 1 个苹果。
    *   如果来了 10 位客人 (n=10)，你削 10 个苹果。
    *   你的工作量和客人数量 (n) **成正比**，是线性增长的。
*   **在代码中**：这就像一个简单的 `for` 循环，遍历数组中的每一个元素。
    ```python
    for item in my_list:
        print(item)
    ```
*   **特点**：非常常见且高效的算法。当数据量增加一倍时，耗时也大约增加一倍。

---

#### 3. O(n²) — 平方时间 (要警惕！)

**操作：“请每一位客人都和所有其他客人握一次手。”**

*   **分析**：
    *   来了 2 位客人 (n=2)：A和B握手，共 1 次。
    *   来了 3 位客人 (n=3)：A和B，A和C，B和C，共 3 次。
    *   来了 10 位客人 (n=10)：大约需要 45 次握手。
    *   你的工作量随着客人数量 (n) 的增加，**急剧增长**！这个增长速度是 `n * n` 级别的。
*   **在代码中**：这通常对应着**嵌套循环**，即一个循环里面还有另一个循环。
    ```python
    for item_a in my_list:
        for item_b in my_list:
            # 做一些比较...
    ```
*   **特点**：在处理小数据时可能没问题，但一旦数据量变大（比如 n > 1000），程序就会变得**极其缓慢**，甚至卡死。

---

<!--v-->
### “大O表示法”是什么？

我们用来描述时间复杂度的 `O(...)` 叫做**大O表示法 (Big O Notation)**。

*   **O** 的意思是 “Order of”（...的量级），你可以把它理解为“大约是...这个级别的”。
*   括号里的 **n** 代表输入数据的大小。

所以：
*   **O(n)** 读作“O of n”，意思是时间复杂度和 `n` 是一个量级（线性关系）。
*   **O(n²)** 读作“O of n square”，意思是时间复杂度和 `n`的平方是一个量级（平方关系）。

**大O表示法会忽略常数**。比如 `O(2n)` 和 `O(n)` 都被认为是 `O(n)`，因为它描述的是**增长趋势**，而不是精确的公式。为 2n 个客人削苹果和为 n 个客人削苹果，它们的“增长模式”是一样的。

<!--v-->
## 知识点3：算法优化（困难、拓展）
**“直观来说，优化算法的过程就是剔除冗余操作的过程，同时也是一种对于空间与时间的平衡。”**

<!--v-->
### 第一部分：剔除冗余操作 —— 让每一步都算数

这部分是优化的**核心目标**。一个低效的算法，其本质就是做了很多“无用功”或“重复功”。优化的过程，就是像一个侦探，找出这些不必要的计算，并用更聪明的方式绕开它们。

我们可以用熟悉的 **“回文子串计数”** 问题来审视这个过程：

*   **暴力解法 (O(n³)) - 冗余的极致：**
    1.  **冗余的子串生成**：通过 `s[i:j+1]` 生成所有可能的子串。
    2.  **冗余的回文检查**：对于每一个子串，都**从头到尾**比较一次进行计数。
    

*   **中心扩展法 (O(n²)) - 第一次剔除：**
    *   **剔除了什么？** 它剔除了“生成子串再检查”这个步骤。它不再生成独立的子串，而是聪明地固定一个中心，向两边扩展。这避免了反复创建子串对象的开销，是一次巨大的进步。
    *   *冗余依然存在：* 算法仍然是“失忆”的。当它处理字符串 `abacaba` 时，它以中间的 `c` 为中心扩展，得到了 `abacaba`。但它并不能利用这个信息来帮助后续的计算。在以右侧的`b`为中心时，其实`aba`这个回文串已经在左侧计算过一次了，但是中心对称法并不知晓。

*   **Manacher's 算法 (O(n)) - 继续剔除冗余：**
    *   **剔除了什么？** 它通过引入 `p` 数组（记忆）和 `right` 最右边界（划定已知区域），**彻底剔除了重复的对称性探索**。
    *   **核心操作**：`p[i] = min(right - i, p[i_mirror])` 这一行代码，就是“剔除冗余”的完美体现。它在说：“别急着从头比较！让我先查查我的记忆（`p`数组），看看关于 `i` 的对称点 `i_mirror`，我们已经知道了什么。利用这些已知信息，我们可以直接跳过一大段已经验证过的回文部分。”
    *   **结论**：Manacher's 算法的全部精髓，就是建立一个**记忆系统**，让算法记住自己探索过的区域的对称特性，从而避免对同一段字符进行重复的回文验证。

---

<!--v-->
### 第二部分：空间与时间的平衡 —— 天下没有免费的午餐

这部分是优化的**现实代价**。想要跑得更快（优化时间），通常需要借助更多的辅助工具，而这些工具需要占用地方（消耗空间/内存）。

**“空间换时间”** 是最经典的平衡策略。

继续看我们的例子：

*   **中心扩展法 (O(n²) 时间, O(1) 空间):**
    *   这个算法非常“节俭”。除了几个用于循环和计数的变量，它几乎不需要任何额外的内存空间。
    *   **代价是什么？** 代价就是它没有“记忆”，所以只能一遍又一遍地进行比较，花费了大量的时间。

*   **Manacher's 算法 (O(n) 时间, O(n) 空间):**
    *   为了达到惊人的线性时间，它付出了空间的代价。
    *   **空间花在哪？**
        1.  `t` 数组：创建了一个长度约为 `2n` 的新字符串。
        2.  `p` 数组：创建了一个长度约为 `2n` 的整数数组，这就是它的“记忆体”。
    *   **如何平衡？** 它通过投资 O(n) 的内存空间，来存储每次计算的关键结果（回文半径）。正是这个“记忆体”的存在，才使得算法能够剔除冗余操作，将时间复杂度从 O(n²) 压到 O(n)。**它用空间投资，换取了时间的巨大回报。**
<!--v-->
#### 算法 1: 暴力解法 (O(n^3))
```
def count_palindromic_substrings_brute_force(s: str) -> int:
    n = len(s)
    count = 0
    for i in range(n):
        for j in range(i, n):
            substring = s[i : j + 1]
            if substring == substring[::-1]:
                count += 1
    return count
```
<!--v-->
#### 算法 2: 中心扩展法 (O(n^2))
```
def count_palindromic_substrings_expand_around_center(s: str) -> int:
    n = len(s)
    count = 0
    if n == 0: return 0
    for i in range(n):
        # 奇数长度
        l, r = i, i
        while l >= 0 and r < n and s[l] == s[r]:
            count += 1; l -= 1; r += 1
        # 偶数长度
        l, r = i, i + 1
        while l >= 0 and r < n and s[l] == s[r]:
            count += 1; l -= 1; r += 1
    return count
```
<!--v-->
#### 算法 3: Manacher's 算法 (O(n))
```
def count_palindromic_substrings_manacher(s: str) -> int:
    t = '#'.join('^{}$'.format(s))
    n = len(t)
    p = [0] * n
    center, right = 0, 0
    count = 0
    for i in range(1, n - 1):
        if i < right:
            p[i] = min(right - i, p[2 * center - i])
        while t[i + 1 + p[i]] == t[i - 1 - p[i]]:
            p[i] += 1
        if i + p[i] > right:
            center, right = i, i + p[i]
        count += (p[i] + 1) // 2
    return count
```