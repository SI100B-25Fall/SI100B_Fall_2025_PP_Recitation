<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>SI100B_Fall_2025_Recitation_3</title>
  <link rel="shortcut icon" href="./favicon.ico" />
  <link rel="stylesheet" href="./dist/reset.css" />
  <link rel="stylesheet" href="./dist/reveal.css" />
  <link rel="stylesheet" href="./dist/theme/simple.css" id="theme" />
  <link rel="stylesheet" href="./css/highlight/github.css" />

  <link rel="stylesheet" href="./_assets/assets/custom.css" />
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section data-markdown data-separator="<!--s-->" data-separator-vertical="<!--v-->">
        <textarea data-template>
            
<p style="font-size: 16px; color: #999; margin:5px; position: absolute;"><a href="..">Homepage</a> | <a href="?print-pdf">Printable Version</a></p>
<div style="display: flex; justify-content: center; align-items: center; height: 700px;">
  <div style="text-align: center; padding: 40px; background-color: white; border: 2px solid rgb(0, 63, 163); border-radius: 20px; box-shadow: 0 0 20px rgba(0,0,0,0.1);">
    <h1 style="font-size: 48px; font-weight: bold; margin-bottom: 20px; color: #333;">SI100B Fall 2025 Recitation 3</h1>
    <p style="font-size: 24px; color: #666;">L4 课堂复习 & HW1 讲解</p>
    <p style="font-size: 16px; color: #999; margin-top: 20px; margin-bottom:5px">SI100B 2025 Staff | 2025-10-10</p>
  </div>
</div>

<!--s-->



<div class="middle center"><div style="width: 100%">

# 作业讲解

</div></div>
<!--s-->
<div class="middle center"><div style="width: 100%">

# Problem 1

</div></div>

<!--v-->
## Problem 1

判断是否是数字，判断是否是合法的  

知识点：条件语句、循环语句、输入输出（进阶：内置函数 `isdigit` 和 `join`）

<!--v-->


## 标准答案（之一）
```py[]
m = float(input()) # input as float to check for non-integer values
n = int(m) # convert to integer
if n!=m or n < 1 or n > 9: 
    # check if input is not an integer or out of range
    print("Invalid")
else:
    for i in range(1, n + 1):
        row = "" # initialize an empty string for each row
        for j in range(1, i + 1):
            row += f"{j}x{i}={i*j:2}" + "\t" # format expression
        print(row)
```

<!--v-->

## 标准答案（进阶）

```py[]
n = input()
if not n.isdigit():
    print("Invalid")
else:
    n = int(n)    
    if 0 < n < 10:
        for i in range(1, n + 1):
            # list comprehension
            row = '\t'.join(f'{j}x{i}={i*j:2}' for j in range(1, i + 1))
            # the single line above equals to: 
            row_str_list = []
            for j in range(1, i + 1): 
                               row_str_list.append(f"{j}x{i}={i*j:2}")
            row = "\t".join(row_str_list)

            print(row)
    else:
        print("Invalid")
```
<!--v-->
### （拓展）优化：链式比较
- 上述进阶答案中我们使用了 `if 0 < n < 10` 而非 `if 0 < n and n < 10`

    - 与许多其他编程语言不同，Python 允许链式比较
 
- 链式写法

    ```py
    0 < n < 10           # 合法且推荐
    1 < x <= 5 < y < 10  # ✓完全合法
    ```

- 等价的传统写法

    ```py
    0 < n and n < 10                    # 也可以
    1 < x and x <= 5 and 5 < y and y < 10  # 冗长
    ```

<!--v-->
### （拓展）优化：链式比较

这么做的**优势**：

1. 可读性更好，更接近数学表达式

2. 性能更好：中间变量只求值一次

3. 更加 Pythonic（有 Python 的风格） 
    - 参考：[Python 的设计哲学](https://realpython.com/ref/glossary/pythonic/)

<!--v-->
### 部分点评
退出分支为什么一定要用 `exit` ？

```py
import sys
sys.exit()
```

```py
num=input()
try:
    num = float(num)
except ValueError:
    print('Invalid')
    exit()
```

- 正确做法：使用 `continue`, `break` 等控制分支中的行为
<!--v-->
## Q1 暴露出的一些问题 

1. 不看提示（如 `f"{j}x{i}={i*j:2}"`）和 Special Hint，也没有仔细检查题目给出的样例
    - 出现大量 WA 时，请首先**检查输出格式**是否符合题目描述和样例要求
    - 不看题目是大忌，之后题目难度上升很容易被卡死

2. 存在一些命名不规范的问题，有些变量命名过多且没有注释辅助理解

3. 部分同学在代码中写死乘法表的每一行，直接查表输出对应行
    - 此类行为称作硬编码 (hardcoding)
    - 题目是为了帮助理解编程的基本概念，直接硬编码在很多方面都不利于练习编程能力

4. 再次强调：作业和考试中，用 `input` 时不要传入字符串

5. **不要**依赖 AI，**不要**用 AI 代做题目

<!--s-->
<div class="middle center"><div style="width: 100%">

# Problem 2

</div></div>

<!--v-->
## Problem 2

线性插值计算  

知识点：多行输入、浮点数运算、格式化输出  

<!--v-->
## 标准答案（之一）

```py[]
x1 = float(input())
y1 = float(input())
x2 = float(input())
y2 = float(input())
x = float(input())

y = y1 + (y2 - y1) / (x2 - x1) * (x - x1)

print(f"{y:.2f}")
```

<!--v-->
## 浮点数格式化输出

Python 提供多种方式来格式化浮点数的输出

- 使用 f-string
```py
y = 34.0
print(f"{y:.2f}")  # 输出: 34.00
```

- 使用 `.format()`
```py
print("{:.2f}".format(y))  # 输出: 34.00
```

<!--v-->

使用 `%` 格式化
```py
print("%.2f" % y)  # 输出: 34.00
```

使用 `round()` 函数
```py
print(round(y, 2))  # 输出: 34.0（注意：不会另外补零）
```

<!--v-->
## 常见错误

1. 运算符优先级错误

    ```py
    # 错误写法
    y = y1 + y2 - y1 / x2 - x1 * (x - x1) 

    # 正确写法：用括号明确优先级
    y = y1 + (y2 - y1) / (x2 - x1) * (x - x1)
    ```

<!--v-->

2. 没有转换类型

    ```py
    x1 = input()  # 这是字符串！
    y = y1 + (y2 - y1) / (x2 - x1) * (x - x1)  # 会报错
    ```

    - 必须使用 `float(input())` 进行类型转换。

<!--s-->
<div class="middle center"><div style="width: 100%">

# Problem 3

</div></div>

<!--v-->
## Problem 3

生成菱形图案  

知识点：循环嵌套、字符串重复、空格填充、对称性

<!--v-->
## 标准答案（之一）

```py
h = int(input())  
w = int(input()) 
c = input()      

middle = h // 2
max_chars = 1 + middle * w

for i in range(middle + 1):
    num_chars = 1 + i * w
    num_spaces = (max_chars - num_chars) // 2
    print(" " * num_spaces + c * num_chars)

for i in range(middle - 1, -1, -1):
    num_chars = 1 + i * w
    num_spaces = (max_chars - num_chars) // 2
    print(" " * num_spaces + c * num_chars)
```

<!--v-->
## 知识点：字符串重复操作

Python中可以用 `*` 运算符重复字符串：

```
print("-" * 3)    # 输出: ---
print(" " * 5)    # 输出: 5个空格
print("AB" * 2)   # 输出: ABAB
```

<!--v-->
## 知识点：用内置函数 `range()` 进行 `for`

- **注意**：`range(start, stop, step)`
    - `start`：起始值（包含）
    - `stop`：结束值（**不包含**）
    - `step`：步长（可以为负数）

<!--v-->
### 在上述标准答案中：
- 先正向遍历（菱形上半）：
    ```py
    for i in range(middle + 1):  # i: 0, 1, 2
        # 生成菱形的上半部分和中间行
    ```

- 再反向遍历（菱形下半）：
    ```py
    for i in range(middle - 1, -1, -1):  # i: 1, 0
        # 生成菱形的下半部分（对称）
    ```

<!--v-->
## 常见错误

- 下半部分包含了中间行

    ```py
    # 错误：从 middle 开始，而不是 middle - 1
    for i in range(middle, -1, -1):
        # ...
    ```
    结果：中间行会被打印两次！

- 空格计算错误

    ```py
    # 错误：用 middle - i 计算空格
    num_spaces = middle - i
    # 这只适用于 w=2 的情况，不具有通用性

    # 注意：使用 print(a, b, ...) 时各元素默认用空格连接
    print(num_spaces * " ", c) 
    # 错误：c 的前面实际是 num_spaces + 1 个空格！
    ```


<!--v-->
## 优化思路

可以只使用一个循环生成整个菱形：
```
for i in range(h):
    # 计算当前行到中间的距离
    distance = abs(i - middle)
    num_chars = max_chars - distance * w
    num_spaces = (max_chars - num_chars) // 2
    print(" " * num_spaces + c * num_chars)
```



<!--s-->
<div class="middle center"><div style="width: 100%">

# Problem 4

</div></div>
<!--v-->
## 标准答案（之一）
```py[]
a = float(input())
guess = a / 2
for _ in range(20):
    guess = (guess + a / guess) / 2
print("{0:.20f}".format(guess))
```

<!--s-->
<div class="middle center"><div style="width: 100%">

# Problem 5

</div></div>

<!--v-->
## 标准答案（之一）
```py[]
s = input()
n = len(s)
cnt = 0

for c in range(n):
    l = r = c
    while l >= 0 and r < n and s[l] == s[r]:
        cnt += 1
        l -= 1
        r += 1

for c in range(n - 1):
    l, r = c, c + 1
    while l >= 0 and r < n and s[l] == s[r]:
        cnt += 1
        l -= 1
        r += 1

print(cnt)

```

<!--v-->
## “为什么超时（TLE）？”
> 我用循环把字符串暴力遍历若干次，肯定也能得出对的结果；可为什么 OJ 说我程序运行超时不通过？

- 我们发现大部分超时了的提交都使用了三层循环。例子如下：
```py[]
s = input()
n = len(s)
count = 0
for i in range(n): # layer 1
    for j in range(i, n): # layer 2
        for k in range((j - i + 1) // 2): # layer 3
            if s[i + k] != s[j - k]:
                break
        else:
            count += 1
print(count)
```

<!--v-->
## “为什么超时（TLE）？”
暴力遍历理论上确实也能得到正确结果，但问题出在用时上：

随着字符串长度 `n` 的增加：
- 上述标答主要由两个 2 重循环组成，其工作量可认为**以 2 次幂（平方）级别增长**
    - 长度为 5 的字符串，最多循环不超过 25 次；长度为 6 则最多不超过 36 次……
- 暴力遍历算法由于是 3 重循环，其工作量可认为**以 3 次幂（立方）级别增长**
    - 长度为 5 则最多循环不超过 125 次，长度为 6 则最多不超过 216 次……

超时的测试点，输入字符串有上千个字符，且包含大量符合回文条件的区段
- 如 `AAAAAAAAAAAAAAAAAAAAA...`
- 在这种情况下，暴力遍历算法的工作增加量远远高于标答，导致用时明显增多

注：此安排的目的是考察将给定的方法逻辑转为代码的实现能力，**并不是有意卡用时**

<!--v-->
## （拓展）知识点 1：尽量使用内置方法
> 我就不使用题目中提示的“中心扩展法”，暴力遍历一定会超时吗？

以下有两种暴力解算方法（用循环直接比较字符串中每个字符）：

- 算法 1： 运行时间长很多，但是可以通过测试点
```py
s = input()
n = len(s)
count = 0
for i in range(n):
    for j in range(i, n):
        if s[i:j+1] == s[i:j+1][::-1]:
            count += 1
print(count)
```
<!--v-->
- 算法 2：将会超时，无法通过测试点
```py
s = input()
n = len(s)
count = 0
for i in range(n):
    for j in range(i, n):
        for k in range((j - i + 1) // 2):
            if s[i + k] != s[j - k]:
                break
        else:
            count += 1
print(count)
```
虽然从**理论时间复杂度**的角度看，随着字符串长度 `n` 的增加，这两种暴力算法的工作量**都以 3 次幂（立方）级别增长**。但是**在实际运行中，算法 1 会比算法 2 快得多**。

原因在于 **Python 解释器的工作方式** 和 **底层代码的实现语言**。

<!--v-->
### 核心原因：C 语言实现 vs. Python循环

- **算法 1：** `s[i:j+1] == s[i:j+1][::-1]`

    这个操作看起来很简单，但在幕后，Python 正在做几件效率极高的事情：
    1.  **`s[i:j+1]` (切片)**: 这是一个单一的操作。Python 的底层实现（用C语言编写）会快速地在内存中定位并复制出这一段子字符串。这是一个高度优化的 C 操作。
    2.  **`[::-1]` (反转)**: 同样，对一个字符串进行反转也是一个单一的、由优化的C代码执行的操作。它会创建一个新的、反转后的字符串。
    3.  **`==` (比较)**: 两个字符串的比较也是在C语言层面完成的，它会逐字节地快速比较内存中的数据。

**关键点**：整个回文检查被打包成了一行代码，Python 解释器将其“委托”给了它内部编译好的、速度极快的 C 语言代码库去执行。这几乎没有 Python 解释器本身的开销。（回忆：为什么这样会更快？）

<!--v-->
- **算法 2：** `for k in range(...)`

    通过一个显式的 `for` 循环来逐个比较字符，其执行时间由两部分组成：

    1.  **`for` 循环自身** ：循环是在 Python 解释器层面运行的
        - 对循环的每一次迭代，解释器自身需要做许多工作：        
            更新循环变量 `k`，计算索引 `i + k` 和 `j - k`，进行数组边界检查，获取 `s[i + k]` 和 `s[j - k]` 的值，执行 `if` 判断以及可能的 `break` 等。

    2.  **解释器开销 (Interpreter Overhead)** ：每步操作都要经过 Python 解释器的处理

        *   这一“解释”本身是有成本的，远比直接执行编译好的 C 语言代码要慢

        *   当字符串很长时，这个 `k` 循环会被执行成千上万次
            *   每次迭代的开销虽然微小，但累加起来就变得非常巨大

---

<!--v-->
### 一个形象的比喻

*   **算法 1** 就像你告诉一位专业的图书管理员（C 语言代码）：“请帮我把这摞书（子字符串）复制一份，再把复制的那份倒序排列，然后告诉我这两摞书是否完全一样。” 管理员用他最熟练、最高效的方法一次性完成了任务。

*   **算法 2** 就像你自己（Python 解释器）来做这件事。你先拿起第一本书和最后一本书，比较一下；然后拿起第二本书和倒数第二本书，比较一下…… 你每比较一次，都需要思考、计算位置、再动手，这个过程中的“思考和准备”时间（解释器开销）远远超过了“比较”本身。

<!--v-->
### 结论

这个例子完美地展示了一个在 Python (以及许多其他高级语言) 中非常重要的编程原则：

**尽可能利用语言内置的、经过高度优化的函数和操作来处理批量数据，而不是自己用显式的循环去实现。**

虽然两种算法的工作量的增长趋势（scaling）是一样的（都是立方级增长），但由于实现方式的不同，算法1的“常数因子”要远远小于算法2，导致在实际运行中表现出巨大的性能差异。


<!--v-->
## （拓展）知识点 2：时间复杂度
### 核心思想

**时间复杂度** 不是用来测量程序运行究竟要花“多少秒”，而是用来描述**一个程序的运行时间会随着处理数据量的增加，而增长得有多“快”**。

它是一种预测，帮助我们判断一个算法在处理大数据时，会不会变得慢得离谱。

---

### 用“做菜”来打比方

假设你是一位厨师，你的任务是为客人准备晚餐。在这里：
*   **算法**：就是你的“操作”。
*   **输入大小 (n)**：就是你要招待的“客人数量”。
*   **时间复杂度**：就是你的操作有多复杂，特别是当客人数量 (n) 增加时，你的工作量会如何变化。


<!--v-->

现在我们来看几种不同“时间复杂度”的操作：

#### 1. $O(1)$ — 常数时间 (最快的)

**操作：“尝一下汤的味道。”**

*   **分析**：不管你是为 1 位客人做汤，还是为 1000 位客人做汤，你“尝一口”这个动作花费的时间是**完全一样**的。它不随客人数量 (n) 的变化而变化。
*   **在代码中**：这就像从数组中获取第一个元素 `array[0]`。无论数组有多大，这个操作都一样快。
*   **特点**：性能极高，是理想情况。

<!--v-->

#### 2. $O(n)$ — 线性时间 (优秀的)

**操作：“为每一位客人削一个苹果。”**

*   **分析**：
    *   如果来了 1 位客人 (n=1)，你削 1 个苹果。
    *   如果来了 10 位客人 (n=10)，你削 10 个苹果。
    *   你的工作量和客人数量 (n) **成正比**，是线性增长的。
*   **在代码中**：这就像一个简单的 `for` 循环，遍历数组中的每一个元素。
    ```py
    for item in my_list:
        print(item)
    ```
*   **特点**：非常常见且高效的算法。当数据量增加一倍时，耗时也大约增加一倍。

<!--v-->

#### 3. $O(n^2)$ — 平方时间 (要警惕)

**操作：“请每一位客人都和所有其他客人握一次手。”**

*   **分析**：
    *   来了 2 位客人 (n=2)：A和B握手，共 1 次。
    *   来了 3 位客人 (n=3)：A和B，A和C，B和C，共 3 次。
    *   来了 10 位客人 (n=10)：大约需要 45 次握手。
    *   工作量随着客人数量 (n) 的增加**急剧增长**
        *   增长速度是 `n * n` 级别
*   **在代码中**：这通常对应着**嵌套循环**，即一个循环里面还有另一个循环。
    ```py
    for item_a in my_list:
        for item_b in my_list:
            # 做一些比较...
    ```
*   **特点**：处理小数据时可能没问题，一旦数据量变大（比如 n > 1000）就会变得**极其缓慢**甚至卡死

---

<!--v-->
### “大O表示法”是什么？

我们用来描述时间复杂度的 `O(...)` 叫做**大O表示法 (Big O Notation)**

*   **O** 的意思是 “Order of”（...的量级）
    - 可以把它理解为“大约是...这个级别的”
*   括号里的 **n** 代表输入数据的大小

所以：
*   $O(n)$ 读作“O of n”，意思是复杂度和 $n$ 是一个量级（线性关系）
*   $O(n^2)$ 读作“O of n square”，意思是复杂度和 $n$ 的平方 是一个量级（平方关系）

**大O表示法会忽略常数**：例如 $O(2n)$ 和 $O(n)$ 都被认为是 $O(n)$

- 大 O 描述的是**增长趋势/增长模式**，而不是精确公式
    - 为 $2n$ 个客人削苹果和为 $n$ 个客人削苹果：对于相同的单调增加的 $n$，工作量增长的趋势是一样的

<!--v-->
## （拓展）知识点 3：算法优化（困难）
**“直观来说，优化算法的过程就是剔除冗余操作的过程，同时也是一种对于空间与时间的平衡。”**

<!--v-->
#### 第一部分：剔除冗余操作 —— 让每一步都算数

这部分是优化的**核心目标**。一个低效的算法，其本质就是做了很多“无用功”或“重复功”。优化的过程，就是像一个侦探，找出这些不必要的计算，并用更聪明的方式绕开它们。

<!--v-->

我们可以用熟悉的 **“回文子串计数”** 问题来审视这个过程：

*   **暴力解法 ($O(n^3)$) - 冗余的极致：**
    1.  **冗余的子串生成**：通过 `s[i:j+1]` 生成所有可能的子串。
    2.  **冗余的回文检查**：对于每一个子串，都**从头到尾**比较一次进行计数。
    
<!--v-->

*   **中心扩展法 (O(n²)) - 第一次剔除：**
    *   **剔除了什么？** 它剔除了“生成子串再检查”这个步骤。它不再生成独立的子串，而是聪明地固定一个中心，向两边扩展。这避免了反复创建子串对象的开销，是一次巨大的进步。
    *   *冗余依然存在：* 算法仍然是“失忆”的。当它处理字符串 `abacaba` 时，它以中间的 `c` 为中心扩展，得到了 `abacaba`。但它并不能利用这个信息来帮助后续的计算。在以右侧的`b`为中心时，其实`aba`这个回文串已经在左侧计算过一次了，但是中心对称法并不知晓。

<!--v-->

*   **Manacher's 算法 (O(n)) - 继续剔除冗余：**
    *   **剔除了什么？** 它通过引入 `p` 数组（记忆）和 `right` 最右边界（划定已知区域），**彻底剔除了重复的对称性探索**。
    *   **核心操作**：`p[i] = min(right - i, p[i_mirror])` 这一行代码，就是“剔除冗余”的完美体现。它在说：“别急着从头比较！让我先查查我的记忆（`p`数组），看看关于 `i` 的对称点 `i_mirror`，我们已经知道了什么。利用这些已知信息，我们可以直接跳过一大段已经验证过的回文部分。”
    *   **结论**：Manacher's 算法的全部精髓，就是建立一个**记忆系统**，让算法记住自己探索过的区域的对称特性，从而避免对同一段字符进行重复的回文验证。

---

<!--v-->
#### 第二部分：空间与时间的平衡 —— 天下没有免费的午餐

这部分是优化的**现实代价**。想要跑得更快（优化时间），通常需要借助更多的辅助工具，而这些工具需要占用地方（消耗空间/内存）。

**“空间换时间”** 是最经典的平衡策略。

<!--v-->

继续看我们的例子：

*   **中心扩展法 ($O(n^2)$ 时间, $O(1)$ 空间):**
    *   这个算法非常“节俭”。除了几个用于循环和计数的变量，它几乎不需要任何额外的内存空间。
    *   **代价是什么？** 代价就是它没有“记忆”，所以只能一遍又一遍地进行比较，花费了大量的时间。

*   **Manacher's 算法 ($O(n)$ 时间, $O(n)$ 空间):**
    *   为了达到惊人的线性时间，它付出了空间的代价。
    *   **空间花在哪？**
        1.  `t` 数组：创建了一个长度约为 `2n` 的新字符串。
        2.  `p` 数组：创建了一个长度约为 `2n` 的整数数组，这就是它的“记忆体”。
    *   **如何平衡？** 它通过投资 $O(n)$ 的内存空间，来存储每次计算的关键结果（回文半径）。正是这个“记忆体”的存在，才使得算法能够剔除冗余操作，将时间复杂度从 $O(n^2)$ 压到 $O(n)$。**它用空间投资，换取了时间的巨大回报。**
<!--v-->
#### 算法 1: 暴力解法 ($O(n^3)$)
```py[]
def count_palindromic_substrings_brute_force(s: str) -> int:
    n = len(s)
    count = 0
    for i in range(n):
        for j in range(i, n):
            substring = s[i : j + 1]
            if substring == substring[::-1]:
                count += 1
    return count
```
<!--v-->
#### 算法 2: 中心扩展法 ($O(n^2)$)
```py[]
def count_palindromic_substrings_expand_around_center(s: str) -> int:
    n = len(s)
    count = 0
    if n == 0: return 0
    for i in range(n):
        # 奇数长度
        l, r = i, i
        while l >= 0 and r < n and s[l] == s[r]:
            count += 1; l -= 1; r += 1
        # 偶数长度
        l, r = i, i + 1
        while l >= 0 and r < n and s[l] == s[r]:
            count += 1; l -= 1; r += 1
    return count
```
<!--v-->
#### 算法 3: Manacher's 算法 ($O(n)$)
```py[]
def count_palindromic_substrings_manacher(s: str) -> int:
    t = '#'.join('^{}$'.format(s))
    n = len(t)
    p = [0] * n
    center, right = 0, 0
    count = 0
    for i in range(1, n - 1):
        if i < right:
            p[i] = min(right - i, p[2 * center - i])
        while t[i + 1 + p[i]] == t[i - 1 - p[i]]:
            p[i] += 1
        if i + p[i] > right:
            center, right = i, i + p[i]
        count += (p[i] + 1) // 2
    return count
```
<!--s-->

<div class="middle center"><div style="width: 100%">

# 知识回顾

</div></div>

<!--v-->
<div class="middle center"><div style="width: 100%">

# Function

</div></div>

<!--v-->
## argument 和 parameter 的区别
在中文场景下二者都可以称作“参数”，但在函数语境中可以进一步区分
- parameter 叫做形参 (formal parameter)，仅在函数内起作用（作用域是此函数体）
    - 在写函数时仅起表示作用，实际调用时才会指向具体对象
- argument 叫做实参 (actual parameter)，通常是调用函数时实际用于函数内运算的值

例如以下这段代码中， `msg` 为 parameter（形参），`str` 为 argument（实参）
```py
def output_msg(msg):
    print("Id of msg", id(msg))

str = "error"
print("Id of str:", id(str)) 
output_msg(str)
```
- Python 的参数传递：调用函数时，仅让形参**指向了实参所指的对象**，即形参和实参的 `id` 相同

<!--v-->
## 预学习知识：可变对象和不可变对象
- **可变 (Mutable) 对象**：如果要修改对象，可直接原地修改，不用重新创建；
  - 常见类型：列表 `list`，字典 `dict`，集合 `set` 等
  - 例：可直接添加、删除或更改列表的元素

- **不可变 (Immutable) 对象**: 对象一旦创建便不可更改；若要修改，只能重新创建一个新的
  - 常见类型：字符串 `string`，整型 `int`，元组 `tuple` 等
  - 例：“修改”一个整数，实际上创建了一个新的整型对象并删除了原先的；元组一旦创建，其内容无法修改

<!--v-->
## 传入不可变对象

```py
def foo(b):
    print("Id of b before revised", id(b))
    b = 2
    print("Id of b after revised", id(b))
    # id will change after revised: a new object
 
a = 1
print("id of a", id(a))
foo(a)
print(a) # 1
```
- 参数传递使变量 `a` 和 `b` 同时指向了 `1` 这个对象（`id` 相同）
- 但执行到 `b = 2` 时，_在函数内_ 会删除原先值为 `1` 的对象，重新创建一个值为 2 的新对象，然后让 b 指向它
    - 而 a 仍然指向 1 这个对象。所以，a 的值不变，仍然为 1

<!--v-->
## 传入可变对象

```py
def foo(l2):
    print("Id of l2 before revised:", id(l2))
    l2.append(4)
    print("Id of l2 after revised:", id(l2)) # same
 
l1 = [1, 2, 3]
print("Id of l1:", id(l1))
foo(l1)
print(l1) # [1, 2, 3, 4]
```
- 当可变对象当作参数传入函数里的时候，改变可变对象的值，就会影响所有指向它的变量
- 函数中的 `l2` 与 `l1` 始终指向同一个对象, 改变 `l2` 的同时修改了 `l1`

<!--v-->
## 全局变量和局部变量

- 函数体是一个代码块
- 最外层无缩进的部分也是一个整体的代码块
- 不同的代码块中，允许有同名变量吗？

```py
# 将摄氏度换算为华氏度
def celsius_to_fahrenheit(celsius):
   fahrenheit = celsius * 9 / 5 + 32
   return fahrenheit

celsius = 23
fahrenheit = celsius_to_fahrenheit(celsius)
```

- `celsius` 和 `fahrenheit` 各出现了两个，但同名并没有影响
    - `celsius` 的原因刚才提到过（形参和实参），但 `fahrenheit` 呢？

<!--v-->
## 全局变量和局部变量

- 有人提到“李华”
  - 英语卷子中的李华
- 如果你身边真的有一个李华同学
  - 你的同学李华

- **全局变量（Global Variable）**：定义在最外层的变量，作用范围为全局

    英语卷子中的李华：所有人都知道他（作用在全局）

- **局部变量（Local Variable）**：定义在有缩进的区域，作用范围为当前代码块

    你的同学李华：只有你学校的人知道他（作用在你的学校内）

- **作用域（Scope）**：变量的作用范围

<!--v-->
## 作用域 (Scope)：示例
```py
which_li_hua = "高考英语卷中"
    
def ShanghaiTech(): 
    which_li_hua = "上海科技大学"
    print("上科大的", which_li_hua) # 上海科技大学
    
def SUSTech(): # 隔壁（存疑）大学没有李华
    print("隔壁大学", which_li_hua) # 高考英语卷中
    
# 外面的人（最外层，即全局）没有听说过别的李华
print("外面的人", which_li_hua) # 高考英语卷中
ShanghaiTech()
SUSTech()
    
# ShanghaiTech 的李华不影响外面的人认知中的李华
print("外面的人", which_li_hua) # 高考英语卷中
```



<!--s-->

<div style="display: flex; justify-content: center; align-items: center; height: 700px;   ">
  <div style="text-align: center; padding: 40px; background-color: white; border-radius: 20px; box-shadow: 0 0 20px rgba(0,0,0,0.1);">
    <div style="display: inline-block; padding: 20px 40px; border-radius: 10 px; margin-bottom: 20px;">
      <h1 style="font-size: 48px; font-weight: bold; margin: 0; color: rgb(16, 33, 89)">Thanks for Listening</h1>
    </div>
    <p style="font-size: 24px; color: #666; margin: 0;">Any questions?</p>
  </div>
</div>
          </textarea>
      </section>
    </div>
  </div>

  <script src="./dist/reveal.js"></script>

  <script src="./mermaid/dist/mermaid.min.js"></script>

  <script src="./plugin/markdown/markdown.js"></script>
  <script src="./plugin/highlight/highlight.js"></script>
  <script src="./plugin/zoom/zoom.js"></script>
  <script src="./plugin/notes/notes.js"></script>
  <script src="./plugin/math/math.js"></script>
  <!-- Font awesome is required for the chalkboard plugin -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Custom controls plugin is used to for opening and closing annotation modes. -->
  <script src="https://cdn.jsdelivr.net/npm/reveal.js-plugins@latest/customcontrols/plugin.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js-plugins@latest/customcontrols/style.css">
  <!-- Chalkboard plugin -->
  <script src="https://cdn.jsdelivr.net/npm/reveal.js-plugins@latest/chalkboard/plugin.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js-plugins@latest/chalkboard/style.css">
  <script>
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }

    // default options to init reveal.js
    var defaultOptions = {
      controls: true,
      progress: true,
      history: true,
      center: false,
      width: 1000,
      pdfSeparateFragments: false,
      transition: 'slide',
      transitionSpeed: 'fast',
      slideNumber: "c/t",
      highlight: {
        highlightOnLoad: false
      },
      plugins: [
        RevealMarkdown,
        RevealHighlight,
        RevealZoom,
        RevealNotes,
        RevealMath.KaTeX,
        RevealChalkboard,
        RevealCustomControls,
      ],
      customcontrols: {
        controls: [
          {
            icon: '<i class="fa fa-pen-square"></i>',
            title: 'Toggle chalkboard (B)',
            action: 'RevealChalkboard.toggleChalkboard();'
          },
          {
            icon: '<i class="fa fa-pen"></i>',
            title: 'Toggle notes canvas (C)',
            action: 'RevealChalkboard.toggleNotesCanvas();'
          }
        ]
      },
      chalkboard: {
        // add configuration here
      },
    };

    // options from URL query string
    var queryOptions = Reveal().getQueryHash() || {};

    var options = extend(defaultOptions, {"_":["./materials/Recitation3_zy/images/Recitation3.md"],"static":"static/Recitation3","template":"./assets/reveal.html","preprocessor":"./assets/preproc.js","scripts":"assets/menu/menu.js,assets/inject.js"}, queryOptions);
  </script>

  <script src="./_assets/assets/menu/menu.js"></script>
  <script src="./_assets/assets/inject.js"></script>

  <script>
    Reveal.initialize(options);
    Reveal.addEventListener('ready', function (event) {
      const blocks = Reveal.getRevealElement().querySelectorAll('pre code:not(.mermaid)');
      const hlp = Reveal.getPlugin('highlight');
      blocks.forEach(hlp.highlightBlock);
    });
  </script>

  <script>
    const mermaidOptions = extend({ startOnLoad: false }, {});
    mermaid.startOnLoad = false;
    mermaid.initialize(mermaidOptions);
    const cb = function (event) {
      mermaid.init(mermaidOptions, '.stack.present > .present pre code.mermaid');
      mermaid.init(mermaidOptions, '.slides > .present:not(.stack) pre code.mermaid');
    }
    Reveal.addEventListener('ready', cb);
    Reveal.addEventListener('slidetransitionend', cb);
  </script>
</body>

</html>